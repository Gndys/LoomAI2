# 无限画布（Next）设计方案

> 更新时间：2026-02-01

## 目标与范围（MVP）
- 在 Next 端实现无限画布：拖拽平移、滚轮缩放、放置图片、选中与移动、基础对齐提示。
- 支持将“生成结果”一键放入画布；支持自动保存（本地 + 服务端）。
- 先不做多人协作、复杂矢量编辑、专业制版编辑（后续阶段）。

## 项目落点
- **前端**：`apps/next-app`（React + Next 16）
- **推荐入口**：`apps/next-app/app/[lang]/(root)/playground`（已有“预览画布/在画布中生成”占位）
- 未来如需独立路由，可新增 `/(root)/canvas` 或 `/(root)/board`。

## 关键设计决策
### 1) 实现路线（先快后稳）
- **Phase 1**：DOM + CSS Transform（`translate + scale`）实现世界坐标系
  - 优点：开发快、调试直观、与现有 UI 组件兼容
  - 风险：对象多时性能会下降（后续迁 Konva/Pixi）
- **Phase 2**：对象量增长后迁移至 Konva 或 Pixi

### 2) 画布坐标与相机（Camera）
- 状态：`{ x, y, scale }`
- 行为：
  - 鼠标滚轮缩放（以鼠标位置为中心）
  - 空格 + 拖拽平移
  - 双击复位
- 变换：`screen = world * scale + translate`

### 3) 数据模型（Scene）
- 统一 Item 结构：
  - `id, type, x, y, width, height, rotation, zIndex, data`
- 先支持类型：`image`, `text`, `rect`
- 交互状态：`selection`, `hover`, `tool`

### 4) 渲染策略
- 画布容器：`CanvasViewport`（控制 transform）
- 图层渲染：
  - 图像/文本 → DOM
  - 控制点/辅助线 → SVG
- 视口裁剪：只渲染进入 viewport 的 items

### 5) 持久化策略
- **本地**：localStorage（防丢稿）
- **服务端**：存 JSON（数据库记录），素材走 `libs/storage`

## 组件规划（建议）
- `CanvasRoot`：全局容器 + 事件分发
- `CanvasViewport`：处理 transform / 相机
- `CanvasScene`：渲染 items
- `CanvasSelection`：选区 / 控制点
- `CanvasToolbar`：工具条
- `CanvasLayerPanel`：图层管理（Phase 2）

## MVP 功能列表
1. 放置图片（本地上传 + 历史生成图）
2. 拖拽移动 / 选中
3. 放大缩小 + 平移
4. 自动保存
5. 画布尺寸自适应 + 无边界背景

## 后续扩展（Phase 2/3）
- 图层面板、对齐吸附、复制/粘贴、快捷键
- PNG/PDF 导出（超大画面需分块渲染）
- 素材库 / 历史生成图管理
- 实时协作（Yjs / Liveblocks）

## 接口与数据结构（草案）
```ts
// Canvas Scene
interface CanvasItem {
  id: string
  type: 'image' | 'text' | 'rect'
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  zIndex?: number
  data: Record<string, any>
}

interface CanvasState {
  id: string
  name: string
  camera: { x: number; y: number; scale: number }
  items: CanvasItem[]
  updatedAt: string
}
```

## 风险与注意点
- 画布元素数量大时，DOM 性能会成为瓶颈
- 需要确保缩放/拖拽时，命中测试准确
- 图片素材上传与存储要接入现有 `libs/storage`

## 待确认问题
1. 画布首期只放图？是否需要文本标注？
2. 是否需要导出 DXF / PDF（制版场景）？
3. 是否需要多人协作或版本历史？

---

> 后续对话如果涉及新增想法或需求，将同步更新本文档。
