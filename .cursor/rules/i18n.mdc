---
description: i18n guideline
globs: 
alwaysApply: false
---
# Internationalization (i18n) Guidelines

## File Structure

```
libs/i18n/
â”œâ”€â”€ locales/
â”‚   â”œâ”€â”€ types.ts       # Simplified type definitions (auto-inferred from en.ts)
â”‚   â”œâ”€â”€ en.ts          # English translations (source of truth for types)
â”‚   â”œâ”€â”€ zh-CN.ts       # Chinese translations
â”‚   â””â”€â”€ index.ts       # Exports all translations
â””â”€â”€ index.ts           # Main i18n configuration
```

## Implementation Methods

This project supports two different implementation methods for internationalization, depending on whether your component is a **Server Component** or **Client Component**.

### ğŸš€ Server Components (Recommended for Server-Side Rendering)

For Server Components (default in Next.js App Router), directly import and use the translations object:

```typescript
// Server Component Example
import { translations } from "@libs/i18n";

export default async function ServerComponent({ params }: { params: { lang: string } }) {
  // Extract language from URL params
  const { lang } = await params;
  
  // Get translations for the current language
  const t = translations[lang as keyof typeof translations];

  // Fetch server-side data if needed
  const data = await fetchSomeData();

  return (
    <div>
      <h1>{t.admin.dashboard.title}</h1>
      <p>{t.admin.dashboard.description}</p>
      
      {/* Use locale for date formatting */}
      <time>
        {t.admin.dashboard.lastUpdated}: {new Date().toLocaleString(lang === 'zh-CN' ? 'zh-CN' : 'en-US')}
      </time>
      
      {/* Display server data with translations */}
      <div>
        <h2>{t.admin.dashboard.metrics.totalRevenue}</h2>
        <span>Â¥{data.revenue}</span>
      </div>
    </div>
  );
}
```

**Key points for Server Components:**
- Use `const { lang } = await params;` to extract language from URL
- Import `translations` directly from `@libs/i18n`
- Access translations with `translations[lang as keyof typeof translations]`
- Perfect for SEO as content is rendered server-side
- No JavaScript bundle overhead for translations

### ğŸ¯ Client Components (For Interactive Components)

For Client Components that need interactivity, use the `useTranslation` hook:

```typescript
'use client';

import { useTranslation } from "@/hooks/use-translation"

export function ClientComponent() {
  const { t, locale, changeLocale } = useTranslation()
  
  const handleSubmit = () => {
    // Client-side logic with translations
    alert(t.common.success)
  }
  
  return (
    <>
      <h1>{t.newFeature.title}</h1>
      <p>{t.newFeature.description}</p>
      
      {/* Interactive form with translations */}
      <form onSubmit={handleSubmit}>
        <label>{t.newFeature.form.labels.name}</label>
        <input placeholder={t.newFeature.form.placeholders.name} />
        <button type="submit">{t.newFeature.actions.submit}</button>
      </form>
      
      {/* Language switcher */}
      <button onClick={() => changeLocale('en')}>English</button>
      <button onClick={() => changeLocale('zh-CN')}>ä¸­æ–‡</button>
    </>
  )
}
```

**Key points for Client Components:**
- Add `'use client';` directive at the top
- Use `useTranslation()` hook for reactive translations
- Access translations with `t.namespace.key`
- Supports `changeLocale()` for language switching
- Perfect for interactive features

### ğŸ”„ Hybrid Architecture (Best Practice)

Combine both approaches for optimal performance:

```typescript
// Server Component (page.tsx)
import { translations } from "@libs/i18n";
import ClientInteractiveComponent from "./ClientComponent";

export default async function HybridPage({ params }: { params: { lang: string } }) {
  const { lang } = await params;
  const t = translations[lang as keyof typeof translations];
  
  // Server-side data fetching
  const serverData = await fetchData();

  return (
    <div>
      {/* Server-rendered content for SEO */}
      <h1>{t.page.title}</h1>
      <p>{t.page.description}</p>
      
      {/* Static content with server translations */}
      <section>
        <h2>{t.page.sections.overview}</h2>
        <p>{serverData.summary}</p>
      </section>
      
      {/* Interactive client component */}
      <ClientInteractiveComponent />
    </div>
  );
}
```

```typescript
// Client Component (ClientComponent.tsx)
'use client';

import { useTranslation } from "@/hooks/use-translation";

export default function ClientInteractiveComponent() {
  const { t } = useTranslation();
  
  return (
    <div>
      {/* Interactive features */}
      <button>{t.actions.submit}</button>
      <form>{/* Interactive form */}</form>
    </div>
  );
}
```

## When to Use Which Method

### âœ… Use Server Components when:
- Content needs to be SEO-friendly
- Page contains mostly static content
- You need server-side data fetching
- Performance is critical (no client-side JS for translations)
- Building admin dashboards, marketing pages, blog posts

### âœ… Use Client Components when:
- Component needs interactivity (forms, buttons, etc.)
- You need language switching functionality
- Component has complex state management
- Building interactive widgets, forms, real-time features

## Adding New Translations (Simplified Workflow)

### ğŸ‰ New Simple Process

1. **Add to English translations first** (`libs/i18n/locales/en.ts`)
   ```typescript
   export const en = {
     // ... existing translations ...
     newFeature: {
       title: "New Feature",
       description: "This is a new feature",
       form: {
         labels: {
           name: "Name",
           email: "Email"
         },
         placeholders: {
           name: "Enter your name",
           email: "Enter your email"
         },
         errors: {
           nameRequired: "Name is required",
           emailInvalid: "Please enter a valid email"
         }
       },
       actions: {
         submit: "Submit",
         submitting: "Submitting...",
         cancel: "Cancel"
       }
     }
   } as const;
   ```

2. **Add corresponding translations to other languages** (`libs/i18n/locales/zh-CN.ts`)
   ```typescript
   export const zhCN = {
     // ... existing translations ...
     newFeature: {
       title: "æ–°åŠŸèƒ½",
       description: "è¿™æ˜¯ä¸€ä¸ªæ–°åŠŸèƒ½",
       form: {
         labels: {
           name: "å§“å",
           email: "é‚®ç®±"
         },
         placeholders: {
           name: "è¯·è¾“å…¥æ‚¨çš„å§“å",
           email: "è¯·è¾“å…¥æ‚¨çš„é‚®ç®±"
         },
         errors: {
           nameRequired: "è¯·è¾“å…¥å§“å",
           emailInvalid: "è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€"
         }
       },
       actions: {
         submit: "æäº¤",
         submitting: "æäº¤ä¸­...",
         cancel: "å–æ¶ˆ"
       }
     }
   } as const;
   ```

3. **Use in components based on their type** (see Implementation Methods above)

### âŒ No Longer Needed

- ~~Manual type definitions in `types.ts`~~
- ~~Defining types before adding translations~~
- ~~Complex type inference setup~~
- ~~Repetitive type maintenance~~

## Type System

The new system uses TypeScript's automatic type inference:

```typescript
// types.ts - Now simplified!
import type { en } from './en'

// Types are automatically inferred from the English translations
export type Translations = typeof en

// Utility types for advanced use cases (optional)
export type DeepKeys<T> = T extends object ? {
  [K in keyof T]: K extends string
    ? T[K] extends object
      ? `${K}.${DeepKeys<T[K]>}`
      : K
    : never
}[keyof T] : never
```

## Best Practices

1. **Translation Organization**
   - Group related translations under meaningful namespaces
   - Keep nesting to a maximum of 4 levels for maintainability
   - Use consistent naming patterns across different features
   - English translations (`en.ts`) serve as the source of truth for structure

2. **Common Patterns**
   - Form fields: include `labels`, `placeholders`, and `errors` objects
   - Buttons: include normal and loading states (e.g., `submit` and `submitting`)
   - Error messages: group under `errors` object
   - Actions: group under `actions` object

3. **Reusable Translations**
   - Put common/shared strings under `common` namespace
   - Use action-related strings under `actions` namespace
   - Keep form-related patterns consistent across features

4. **Error Handling**
   - Always include both required and invalid error states
   - Use `common.unexpectedError` for unknown errors
   - Follow the pattern: `namespace.feature.errors.errorType`

5. **Loading States**
   - Include loading state text for async actions
   - Follow the pattern: `verb` and `verbIng` (e.g., `submit` and `submitting`)

6. **Performance Considerations**
   - Prefer Server Components for static content (better SEO, no JS overhead)
   - Use Client Components only when interactivity is needed
   - Consider hybrid architecture for complex pages
   - Server Components load faster and are more SEO-friendly

