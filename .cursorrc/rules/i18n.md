# Internationalization (i18n) Guidelines

## File Structure

```
libs/i18n/
├── locales/
│   ├── types.ts       # Type definitions for all translations
│   ├── en.ts          # English translations
│   ├── zh-CN.ts       # Chinese translations
│   └── index.ts       # Exports all translations
└── index.ts           # Main i18n configuration
```

## Adding New Translations

1. **Define Types First**
   - Always start by adding new translation keys to `types.ts`
   - Group related translations under appropriate namespaces (e.g., `auth`, `common`)
   - Use descriptive key names that reflect their usage

```typescript
// Example structure in types.ts
export type Locale = {
  namespace: {
    feature: {
      title: string
      description: string
      // Add form-related translations
      form: {
        labels: { ... }
        placeholders: { ... }
        errors: { ... }
      }
      // Add action-related translations
      actions: {
        submit: string
        cancel: string
      }
    }
  }
}
```

2. **Common Patterns**
   - Form fields: include `label`, `placeholder`, and `error` messages
   - Buttons: include normal and loading states (e.g., `submit` and `submitting`)
   - Error messages: group under `errors` object
   - Terms & Policies: reuse common translations (`common.and`, `auth.termsNotice`, etc.)

3. **Component Implementation**
   ```typescript
   'use client';
   
   import { useTranslation } from "@/hooks/use-translation"
   
   export function YourComponent() {
     const { t, locale } = useTranslation()
     
     return (
       <>
         <h1>{t.namespace.feature.title}</h1>
         <form>
           <Label>{t.namespace.feature.form.labels.fieldName}</Label>
           <Input 
             placeholder={t.namespace.feature.form.placeholders.fieldName}
             // ... 
           />
           {error && <span>{t.namespace.feature.form.errors.fieldName}</span>}
         </form>
       </>
     )
   }
   ```

## Best Practices

1. **Type Organization**
   - Group related translations under meaningful namespaces
   - Keep nesting to a maximum of 4 levels for maintainability
   - Use consistent naming patterns across different features

2. **Reusable Translations**
   - Put common/shared strings under `common` namespace
   - Use action-related strings under `actions` namespace
   - Keep form-related patterns consistent across features

3. **Error Handling**
   - Always include both required and invalid error states
   - Use `common.unexpectedError` for unknown errors
   - Follow the pattern: `namespace.feature.errors.errorType`

4. **Loading States**
   - Include loading state text for async actions
   - Follow the pattern: `verb` and `verbIng` (e.g., `submit` and `submitting`)

## Examples

1. **Form Field Pattern**
   ```typescript
   // In types.ts
   feature: {
     fieldName: string                  // Label
     fieldNamePlaceholder: string       // Placeholder
     errors: {
       requiredFieldName: string        // Required error
       invalidFieldName: string         // Validation error
     }
   }
   ```

2. **Action Button Pattern**
   ```typescript
   // In types.ts
   feature: {
     submit: string                     // "Create account"
     submitting: string                 // "Creating account..."
   }
   ```

3. **Terms & Privacy Pattern**
   ```typescript
   // In component
   <p>
     {t.feature.termsNotice}{" "}
     <a href="#">{t.feature.termsOfService}</a>{" "}
     {t.common.and}{" "}
     <a href="#">{t.feature.privacyPolicy}</a>
   </p>
   ```

## Adding New Languages

1. Create a new file in `locales/` (e.g., `ja.ts` for Japanese)
2. Import and implement the `Locale` type
3. Add the locale to `locales` array in `i18n/index.ts`
4. Update the `SupportedLocale` type

Remember: The English translation (`en.ts`) serves as the source of truth for all translations. 